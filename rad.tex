\documentclass[titlepage]{article}
\usepackage{amsthm,amssymb,amsmath,latexsym,graphicx}
\usepackage[serbian]{babel}	
\usepackage[T1]{fontenc}
%\newcommand{\qed}{\hfill $\Box$\vspace*{4mm}}
\newtheorem{thm}{Teorema}[section]

\theoremstyle{remark}
\newtheorem{rem}[thm]{Napomena}

\theoremstyle{definition}
\newtheorem{df}[thm]{Definicija}

\newtheoremstyle{algorithm}	
{\topsep}                    % Space above
    {\topsep}                    % Space below
    {\itshape}                   % Body font
    {}                           % Indent amount
    {\scshape}                   % Theorem head font
    {:}                          % Punctuation after theorem head
    {\newline}                       % Space after theorem head
    {}  % Theorem head spec (can be left empty, meaning ‘normal’)

\theoremstyle{algorithm}
\newtheorem*{alg}{Algoritam}

\begin{document}

	\title{\sc Geneteski Algoritmi i Problem Trgova\v{c}kog Putnika}

	\author{Daniel Sila\dj i\\
		Gimnazija "Jovan Jovanovi\'{c} Zmaj"\\
		Novi Sad}
	\maketitle

	\begin{abstract}
		Ovaj rad se bavi primenom genetskih algoritama u re\v{s}avanju problema trgova\v{c}kog putnika. \\
	\end{abstract}

	\section{Uvod}
        \subsection{\v{S}ta je problem trgova\v{c}kog putnika?}
        Neformalno, problem trgova\v{c}kog putnika (engl. Travelling Salesman Problem - TSP) mo\v{z}emo formulisati na slede\'{c}i nacin: Dato je n gradova, poznate su sve udaljenosti me\dj u njima; trgova\v{c}ki putnik treba da obi\dj e sve te gradove i da se na kraju vrati u grad odakle je krenuo, a da pri tome pre\dj e najkra\'{c}u razdaljinu.
        Formalna definicija problema trgova\v{c}kog putnika glasi:
        \begin{df}[\bf Problem trgova\v{c}kog putnika-TSP]
        Ako je dat kompletan neusmeren te\v{z}inski graf, sa nenegativnim celobrojnim te\v{z}inama naci Hamiltonovu putanju sa najmanjom te\v{z}inom.
        \end{df}
        Pored optimizacijske varijante ovog problema, postoji i tzv. forma problema odlu\v{c}ivanja:
        \begin{df}[\bf TSP - odlu\v{c}ivanje]
        Ako je dat kompletan te\v{z}inski graf i pozitivan realan broj  $L$, treba odrediti da li postoji Hamiltonov put kra\'{c}i od $L$?\\
        \end{df}
        
        \subsubsection{Istorija}
        TSP prvi put spominju irski i britanski matemati\v{c}ari Sir William Rowan Hamilton i Thomas Penyngton Kirkman sredinom XIX veka. Hamilton je 1857. godine izmislio Ikozijansku igru, u kojoj je cilj da se nadje zatvorena putanja koja prolazi kroz (neke) ivice dodekaedra i svako njegovo teme ta\v{c}no jednom. U dana\v{s}njoj terminologiji, to bi zna\v{c}ilo na\'{c}i Hamiltonovu putanju u grafu kome su \v{c}vorovi temena, a ivice ivice dodekaedra.\\
        \begin{center}
          \includegraphics[scale=0.5]{Hamiltonian_path.pdf}
          slika 1: ikozijanska igra
        \end{center}
        Nakon njih, slede\'{c}a osoba koja se ozbiljno bavila TSP-om je bio Karl Menger, 1930-ih godina. On je u svom radu spomenuo trivijalni brute-force algoritam, konstatovao suboptimalnost heuristike ,,najbli\v{z}eg kom\v{s}ije'' i definisao TSP onako kako se danas defini\v{s}e.\\
        U narednim decenijama, problem je postajao sve vi\v{s}e popularan i izu\v{c}avan od strane mnogih matemati\v{c}ara, informati\v{c}ara, fizi\v{c}ara,...\\
        
        \subsubsection{Algoritmi za re\v{s}avanje TSP}
        O\v{c}igledno, TSP se mo\v{z}e re\v{s}iti brute-force algoritmom(slo\v{z}enosti $\mathcal{O}(n!)$) isprobavaju\'{c}i sve mogu\'{c}e permutacije gradova.
        Danas nije poznat ni jedan daterministi\v{c}ko polinomni algoritam za njegovo re\v{s}avanje - TSP spada u klasu NP tvrdih problema. Me\dj utim, Datzig, Fulkerson i Johnson su u svom radu iz 1954 dali metodu koja se zasniva na celobrojnom programiranju, i iako je jo\v{s} uvek eksponencijalne slo\v{z}enosti, znatno je br\v{z}a od svih ostalih do sada poznatih metoda.\\
        Postoje tako\dj e i aproksimativni algoritmi, npr. genetski algoritmi, Lin-Keringan potezi, tabu pretra\v{z}ivanje, itd.
        
    	\subsection{\v{S}ta su genetski algoritmi i \v{c}emu slu\v{z}e?}
    		Genetski algoritmi (u daljem tekstu GA) su porodica algoritama inspirisanih Darvinovom teorijom evolucije. Prvi radovi iz ove oblasti su nastali 60-tih godina pro\v{s}log veka, ali se u ve\'{c}ini izvora kao tvorac ove oblasti uzima John Holland. On je 1975. godine napisao knjigu "Adaptation in natural and artificial systems".
        GA imaju za cilj re\v{s}avanje problema kombinatorne optimizacije, tj problema u kojima se tra\v{z}i minimum ili maksimum neke funkcije . Po\v{s}to je prostor pretra\v{z}ivanja (skup re\v{s}enja) ponekad prevelik (i njegovo kompletno pretra\v{z}ivanje se ne mo\v{z}e izvr\v{s}iti u nekom doglednom vremenu), a optimalno re\v{s}enje nije neophodno (prihvata se i neko pribli\v{z}no, suboptimalno re\v{s}enje), mogu se koristiti genetski algoritmi. \\
      U GA, svako pjedina\v{c}no re\v{s}enje je predstavljeno jednom jedinkom, koja sadr\v{z}i gene, tj delove re\v{s}enja. Nad njima se vr\v{s}e operatori mutacije i ukr\v{s}tanja (kao mehanizam pretrage) i selekcije (usmerava algoritam ka perspektivnim delovima pretra\v{z}iva\v{c}kog prostora).

    	\subsection{Osnovni operatori u genetskim algoritmima}
            \begin{df}
                {\bf Fitness funkcija} je genetski operator koji svakoj jedinki dodeljuje vrednost $f_i$ koja oslikava kvalitet te jedinke.
            \end{df}
            Kod TSP, to je ukupna du\v{z}ina puta predstavljenog tom jedinkom.\\
            
            Slede\'{c}i operator je operator selekcije. U osnovnim crtama, princip rada selekcije je sli\v{c}an kao u stvarnom \v{z}ivotu: cilj je da se odabere genetski materijal koji ce se preneti u narednu generaciju. Kod ovog operatora je bitno sa\v{c}uvati raznovrsnost, kao i kvalitet genetskog materiala, ina\v{c}e \'{c}e se dobra re\v{s}enja mo\v{z}da zauvek izgubiti.
            \begin{df}
                {\bf Selekcija} je genetski operator koji bira jedinke koje \'{c}e se ukr\v{s}tati i/ili preneti u slede\'{c}u generaciju.
            \end{df}
            \begin{df}
                {\bf Ukr\v{s}tanje} je genetski operator koji na osnovu 2 date jedinke (roditelja) konstrui\v{s}e 2 nove jedinke (decu), koje su nastale kombinovanjem genetskog materijala roditelja.
            \end{df}
            Cilj ovog operatora je da se ukr\v{s}tanjem dva postoje\'{c}a re\v{s}enja dobiju nova, obi\v{c}no kvalitetnija re\v{s}enja.
            \begin{df}
                {\bf Mutacija} genetski operator koji (uglavnom) nasumi\v{c}no mutira genetski materijal date jedinke.
            \end{df}
            Mutacijom se vra\'{c}a raznovrsnog genetskog materijala u populaciju. Ipak, prekomerna mutacija mo\v{z}e svesti algoritam na nasumi\v{c}nu pretragu, pa se zato uvodi verovatnoca mutacije, koja je uglavnom manja od 5\%.
    \section{Kori\v{s}\'{c}ene metode}
        \subsection{Konstrukcija po\v{c}etnog re\v{s}enja}
        Za konstrukciju po\v{c}etnog re\v{s}enja koji\v{s}cen je greedy algoritam koji od zadatog po\v{c}etnog grada gradi put tako \v{s}to uvek bira grad najbli\v{z}i poslednjem dodatom gradu. Iako je ovaj pristup suboptimalan, u praksi naj\v{c}e\v{s}\'{c}e daj prili\v{c}no dobra re\v{s}enja koja se od optimalnog retko razlikuju za vi\v{s}e od 10\%.
        % TODO: Grafik optimalnih i greedy re\v{senja}
        \subsection{Selekcija}
        U ovom radu su kori\v{s}cena su dva algoritma za selekciju:
        \begin{rem}
            Promenljiva $f_i$ predstavlja vrednost fitness-funkcije $i$-te jedinke u populaciji,  $p_i$ verovatnocu da bas $i$-ta jedinka bude odabrana prilikom selekcije, a $r_i$ rang $i$-te jedinke, tako da najkvalitetnija jedinka (gledaju\'{c}i fitness) ima rang $1$, a najnekvalitetnija $n$. Tako\dj{}e, va\v{z}i pretpostavka da u populaciji ima ta\v{c}no $n$ jedinki.
        \end{rem}
        \begin{description}
          \item[Prosta, rulet selekcija]
            Svaka jedinka ima verovatno\'{c}u selekcije direktno proporcionalnu njenoj fitness-vrednosti, tj: $$p_i=\frac{f_i}{\sum_{i=1}^{n}{f_j}}$$
          \item[Selekcija zasnovana na rangu]
            Svaka jedinka ima verovatno\'{c}u selekcije direktno proporcionalnu njenom rangu, tj: $$p_i=\frac{r_i}{\sum_{i=1}^{n}{j}}$$
        \end{description}
        \subsection{Ukr\v{s}tanje}
        Kori\v{s}cena su 2 algoritma za ukr\v{s}tanje:
        \begin{description}
          \item[Ukr\v{s}tanje rekombinacijom grana (edge recombination)]
            Ovaj algoritam od 2 roditelja pravi 1 dete, i to na sledeci nacin:\\
            \begin{alg}
            \begin{enumerate}
              \item Konstrui\v{s}e matrice povezanosti:
              $\begin{array}{ccc}
                g_1: & g_n & g_2 \\
                g_2: & g_1 & g_3 \\
                \vdots & \vdots & \vdots \\
                g_n: & g_{n-1} & g_1  \\
              \end{array}$
              \textbf{,}
              $\begin{array}{ccc}
                g'_1: & g'_n & g'_2 \\
                g'_2: & g'_1 & g'_3 \\
                \vdots & \vdots & \vdots \\
                g'_n: & g'_{n-1} & g'_1  \\
              \end{array}$
              \item Napravi njihovu uniju
               $\begin{array}{ccccc}
                g_1 = g'_{i_1}: & g_n & g_2 & g'_{i_{1}-1} & g'_{i_{1}+1} \\
                g_2 = g'_{i_2}: & g_1 & g_3 & g'_{i_{2}-1} & g'_{i_{2}+1} \\
                \vdots & \vdots & \vdots & \vdots & \vdots \\
                g_n = g'_{i_n}: & g_{n-1} & g_1 & g'_{i_{n}-1} & g'_{i_{n}+1}  \\
              \end{array}$
              \item Napravi novu praznu listu $L$
              \item Odabere po\v{c}etni \v{c}vor $L_1$
              \item Odabere cvorove $L_2, \ldots L_{n-1}, L_n$ po sledecem principu:\\
              $L_{i+1}$ je sused \v{c}vora $L_i$, takav da $L_{i+1}$ ima najmanji mogu\'{c}i broj suseda, i ne nalazi se ve\'{c} u $L$
              \item Lista $L$ je nova jedinka
            \end{enumerate}
            \end{alg}
          \item[Ukr\v{s}tanje parcijalnim mapiranjem] Ovaj algoritam proizvodi 2 potomka od 2 roditelja.
          \begin{itemize}
            \item Odaberu se 2 cvora po slu\v{c}ajnom izboru, $a$ i $b$
            \item Iz roditelja 1 se kopira put od $a$ do $b$ u dete 1, a iz roditelja 2 u dete 2.
            \item Dokle god to mo\v{z}e (tj. dok se svaki \v{c}vor javalja samo jednom u detetu), algoritam popunjava pozicije u detetu 1 sa putevima iz roditelja 2 i  u detetu 2 sa putevima iz roditelja 2
            \item Ostatak \v{c}vorova se u decu dodaje na slu\v{c}ajan na\v{c}in
          \end{itemize}
        \end{description}
        \subsection{Mutacija}
        Kori\v{s}\'{c}ena su 2 algoritma za mutaciju:
        \begin{description}
          \item[Greedy mutacija]
            Biraju se 2 slu\v{c}ajna grada, i gleda se da li se njihovom zamenom dobija kra\'{c}i put.
          \item[2opt mutacija]
            \begin{enumerate}
              \item Biraju se 2 para susednih gradova, $(a_1, b_1)$ i $(a_2, b_2)$
              \item Ako je $d(a_1, b_2)+d(a_2, b_1)<d(a_1, b_1)+ d(a_2, b_2)$, ivice $(a_1, b_1)$ i $(a_2, b_2)$ se bri\v{s}u i dodaju se ivice $(a_1, b_2)$ i $(a_2, b_1)$
            \end{enumerate}
        \end{description}
    \section{Rezultati}
        \subsection{Tehni\v{c}ki detalji}
        Program je napisan u programskom jeziku C++. Kao osnova za genetski algoritam, kori\v{s}\'{c}ena je biblioteka GALib, verzija 2.4.7, autora Mathew Wall-a sa MIT-a. Za grafi\v{c} prikaz su kori\v{s}\'{c}ene biblioteke SDL i OpenGL. \\
        U planu je izrada korisni\v{c}kog interfejsa, gde korisnik mo\v{z}e da bira izme\dj u grafi\v{c}kog i tekstualnog unosa podataka(koordinata gradova).
        \subsection{Na\v{c}in upotrebe programa}
        Glavni algoritam se nalazi u programu pod imenom tsp.exe. Program se koristi uno\v{s}enjem koordinata gradova u fajl, i to u slede\'{c}em formatu:\\
        $$\begin{array}{ccc}
        ID_1 & X_1 & Y_1 \\
        ID_2 & X_2 & Y_2 \\
        \vdots & \vdots & \vdots \\
        ID_n & X_n & Y_n \\
        \end{array}$$ 
        pri \v{c}emu su koordinate bilo koji realni brojevi, a $ID_i$ ceo broj. Tako snimljeni fajl se samo prevu\v{c}e na $tsp.exe$. Tog trenutka \'{c}e se zapo\v{c}eti inicijalizacija, i za par trenutaka \'{c}e se pojaviti grafi\v{c}ki prikaz optimalnog re\v{s}enja. Program prestaje sa radom kada populacija potpuno konvergira(za 250 gradova za par sekundi, a za 1000, to je otprilike 2min). U konzoli se vidi du\v{z}ina najboljeg i najgoreg puta u trenutnoj generaciji, kao i njihov odnos.
        \subsection{Primeri}
    \section{Reference}

	\end{document} 